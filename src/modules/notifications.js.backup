// Notification fetching, polling, and display

export let notificationPollingIntervals = {
    mastodon: null,
    twitter: null,
    bluesky: null
};

export function getAllCachedNotifications() {
    const cached = localStorage.getItem('allNotifications');
    return cached ? JSON.parse(cached) : [];
}

export function saveAllNotifications(notifications) {
    localStorage.setItem('allNotifications', JSON.stringify(notifications));
}

export function clearNotificationsCache() {
    localStorage.removeItem('allNotifications');
    localStorage.removeItem('mastodonLastNotificationId');
    localStorage.removeItem('twitterLastMentionId');
    localStorage.removeItem('blueskyLastNotificationTimestamp');
    
    const notificationsList = document.getElementById('notificationsList');
    const noNotifications = document.getElementById('noNotifications');
    notificationsList.innerHTML = '';
    noNotifications.style.display = 'block';
    noNotifications.textContent = 'Click "Load Notifications" to check for replies, likes, and mentions across your platforms.';
    window.showStatus('Notification cache cleared!', 'success');
}

export function startNotificationPolling() {
    stopNotificationPolling();
    
    const settings = JSON.parse(localStorage.getItem('socialSoxSettings') || '{}');
    const intervals = settings.pollingIntervals || { mastodon: 5, twitter: 60, bluesky: 5 };
    const exclusions = settings.notificationExclusions || {};
    
    ['mastodon', 'twitter', 'bluesky'].filter(platform => !exclusions[platform]).forEach(platform => {
        const intervalMinutes = intervals[platform];
        const intervalMs = intervalMinutes * 60 * 1000;
        
        notificationPollingIntervals[platform] = setInterval(() => {
            console.log(`Auto-checking ${platform} notifications...`);
            loadPlatformNotifications(platform, true);
        }, intervalMs);
    });
}

export function restartNotificationPolling() {
    startNotificationPolling();
}

export function stopNotificationPolling() {
    Object.keys(notificationPollingIntervals).forEach(platform => {
        if (notificationPollingIntervals[platform]) {
            clearInterval(notificationPollingIntervals[platform]);
            notificationPollingIntervals[platform] = null;
        }
    });
}

export async function loadPlatformNotifications(platform, silent = true) {
    const platformName = platform.charAt(0).toUpperCase() + platform.slice(1);
    window.showToast(`Checking ${platformName}...`, 'info', silent ? 1500 : 2000);
    
    const newNotifications = [];
    
    try {
        if (platform === 'mastodon') {
            const mastodonInstance = document.getElementById('mastodon-instance').value;
            const mastodonToken = document.getElementById('mastodon-token').value;
            
            if (mastodonInstance && mastodonToken) {
                const lastSeenId = localStorage.getItem('mastodonLastNotificationId');
                const mastodonNotifs = await fetchMastodonNotifications(mastodonInstance, mastodonToken, lastSeenId);
                newNotifications.push(...mastodonNotifs.map(n => ({ ...n, platform: 'mastodon' })));
                
                if (mastodonNotifs.length > 0) {
                    const latestId = Math.max(...mastodonNotifs.map(n => parseInt(n.id)));
                    localStorage.setItem('mastodonLastNotificationId', latestId.toString());
                }
            }
        } else if (platform === 'twitter') {
            const twitterKey = document.getElementById('twitter-key').value;
            const twitterSecret = document.getElementById('twitter-secret').value;
            const twitterToken = document.getElementById('twitter-token').value;
            const twitterTokenSecret = document.getElementById('twitter-token-secret').value;
            
            if (twitterKey && twitterSecret && twitterToken && twitterTokenSecret) {
                const twitterNotifs = await fetchTwitterNotifications(twitterKey, twitterSecret, twitterToken, twitterTokenSecret);
                newNotifications.push(...twitterNotifs.map(n => ({ ...n, platform: 'twitter' })));
            }
        } else if (platform === 'bluesky') {
            const blueskyHandle = document.getElementById('bluesky-handle').value;
            const blueskyPassword = document.getElementById('bluesky-password').value;
            
            if (blueskyHandle && blueskyPassword) {
                const blueskyNotifs = await fetchBlueskyNotifications(blueskyHandle, blueskyPassword);
                newNotifications.push(...blueskyNotifs.map(n => ({ ...n, platform: 'bluesky' })));
                
                if (blueskyNotifs.length > 0) {
                    const latestTimestamp = blueskyNotifs.reduce((latest, n) => {
                        return new Date(n.timestamp) > new Date(latest) ? n.timestamp : latest;
                    }, blueskyNotifs[0].timestamp);
                    localStorage.setItem('blueskyLastNotificationTimestamp', latestTimestamp);
                }
            }
        }
        
        const cachedNotifications = getAllCachedNotifications();
        const cachedIds = new Set(cachedNotifications.map(n => n.id));
        
        const uniqueNewNotifications = newNotifications
            .filter(n => !cachedIds.has(n.id))
            .map(n => ({ ...n, isNew: true }));
        
        if (uniqueNewNotifications.length > 0) {
            const updatedCache = [...cachedNotifications, ...uniqueNewNotifications];
            localStorage.setItem('allNotifications', JSON.stringify(updatedCache));
            
            displayNotifications(updatedCache);
            
            if (window.electron && window.electron.showOSNotification) {
                const count = uniqueNewNotifications.length;
                const platformName = platform.charAt(0).toUpperCase() + platform.slice(1);
                window.electron.showOSNotification(
                    `New ${platformName} notifications`,
                    `You have ${count} new notification${count > 1 ? 's' : ''} on ${platformName}`,
                    platform
                );
            }
        }
        
    } catch (error) {
        console.error(`${platform} notifications error:`, error);
        if (error.message.toLowerCase().includes('rate limit')) {
            const errorNotif = {
                id: `error-${platform}-${Date.now()}`,
                platform,
                error: true,
                message: error.message,
                timestamp: new Date().toISOString()
            };
            const allNotifs = getAllCachedNotifications();
            allNotifs.push(errorNotif);
            saveAllNotifications(allNotifs);
            displayNotifications(allNotifs);
            setTimeout(() => {
                markAsSeen(errorNotif.id);
            }, 10000);
        } else if (!silent) {
            window.showStatus(`Failed to load ${platform} notifications: ${error.message}`, 'error');
        }
    }
}

export async function loadNotifications(silent = false) {
    const btn = document.getElementById('loadNotificationsBtn');
    const notificationsList = document.getElementById('notificationsList');
    const noNotifications = document.getElementById('noNotifications');
    
    if (!silent) {
        btn.disabled = true;
        btn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> Loading...';
        lucide.createIcons();
    }
    
    noNotifications.style.display = 'none';
    
    try {
        const settings = JSON.parse(localStorage.getItem('socialSoxSettings') || '{}');
        const exclusions = settings.notificationExclusions || {};
        
        const platformsToCheck = ['mastodon', 'twitter', 'bluesky'].filter(platform => !exclusions[platform]);
        const loadPromises = platformsToCheck.map(platform => 
            loadPlatformNotifications(platform, silent)
        );
        
        await Promise.all(loadPromises);
        
        const allNotifications = getAllCachedNotifications();
        displayNotifications(allNotifications);
        
        if (!silent) {
            window.showStatus('Notifications loaded!', 'success');
        }
        
    } catch (error) {
        console.error('Error loading notifications:', error);
        if (!silent) {
            window.showStatus(`Error loading notifications: ${error.message}`, 'error');
        }
    } finally {
        if (!silent) {
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="refresh-cw" class="w-4 h-4"></i> Load Notifications';
            lucide.createIcons();
        }
    }
}

export function markAsSeen(notificationId) {
    const allNotifs = getAllCachedNotifications();
    const notif = allNotifs.find(n => n.id === notificationId);
    if (notif) {
        notif.dismissed = true;
        notif.isNew = false;
        saveAllNotifications(allNotifs);
        displayNotifications(allNotifs);
    }
}

export function markAllAsRead() {
    const allNotifs = getAllCachedNotifications();
    let hasChanges = false;
    
    allNotifs.forEach(notif => {
        if (!notif.dismissed || notif.isNew) {
            notif.dismissed = true;
            notif.isNew = false;
            hasChanges = true;
        }
    });
    
    if (hasChanges) {
        saveAllNotifications(allNotifs);
        displayNotifications(allNotifs);
        window.showToast('All notifications marked as read', 'success');
    } else {
        window.showToast('No unread notifications to mark', 'info');
    }
}

export function testNotification() {
    if (window.electron && window.electron.showOSNotification) {
        window.electron.showOSNotification(
            'Test Notification',
            'This is a test notification from SocialSox!',
            'test'
        );
        window.showToast('Test notification sent!', 'success');
    } else {
        window.showToast('Notifications not supported', 'error');
    }
}

